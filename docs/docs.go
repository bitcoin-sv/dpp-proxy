// Package docs GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import (
	"bytes"
	"encoding/json"
	"strings"
	"text/template"

	"github.com/swaggo/swag"
)

var doc = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "https://github.com/libsv/go-payment_protocol/blob/master/CODE_STANDARDS.md",
        "contact": {},
        "license": {
            "name": "ISC",
            "url": "https://github.com/libsv/go-payment_protocol/blob/master/LICENSE"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/payment/{paymentID}": {
            "get": {
                "description": "Creates a payment request based on a payment id (the identifier for an invoice).",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Payment"
                ],
                "summary": "Request to pay an invoice and receive back outputs to use when constructing the payment transaction",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Payment ID",
                        "name": "paymentID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "contains outputs, merchant data and expiry information, used by the payee to construct a transaction",
                        "schema": {
                            "$ref": "#/definitions/dpp.PaymentTerms"
                        }
                    },
                    "400": {
                        "description": "returned if the user input is invalid, usually an issue with the paymentID",
                        "schema": {
                            "$ref": "#/definitions/server.ClientError"
                        }
                    },
                    "404": {
                        "description": "returned if the paymentID has not been found",
                        "schema": {
                            "$ref": "#/definitions/server.ClientError"
                        }
                    },
                    "500": {
                        "description": "returned if there is an unexpected internal error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a payment based on a payment id (the identifier for an invoice).",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Payment"
                ],
                "summary": "A user will submit an SpvEnvelope along with other information that is validated before being broadcast to the network.",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Payment ID",
                        "name": "paymentID",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "payment message used in BIP270",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dpp.PaymentCreateArgs"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "if success, error code will be empty, otherwise it will be filled in with reason",
                        "schema": {
                            "$ref": "#/definitions/dpp.PaymentACK"
                        }
                    },
                    "400": {
                        "description": "returned if the user input is invalid, usually an issue with the paymentID",
                        "schema": {
                            "$ref": "#/definitions/server.ClientError"
                        }
                    },
                    "404": {
                        "description": "returned if the paymentID has not been found",
                        "schema": {
                            "$ref": "#/definitions/server.ClientError"
                        }
                    },
                    "500": {
                        "description": "returned if there is an unexpected internal error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/proofs/{txid}": {
            "post": {
                "description": "Creates a json envelope proof",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Proofs"
                ],
                "summary": "InvoiceCreate proof",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Transaction ID",
                        "name": "txid",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "JSON Envelope",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/envelope.JSONEnvelope"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": ""
                    }
                }
            }
        }
    },
    "definitions": {
        "bt.FeeQuote": {
            "type": "object"
        },
        "dpp.Merchant": {
            "type": "object",
            "properties": {
                "address": {
                    "description": "Address is the merchants store / head office address.",
                    "type": "string",
                    "example": "1 the street, the town, B1 1AA"
                },
                "avatar": {
                    "description": "AvatarURL displays a canonical url to a merchants avatar.",
                    "type": "string",
                    "example": "http://url.com"
                },
                "email": {
                    "description": "Email can be sued to contact the merchant about this transaction.",
                    "type": "string",
                    "example": "merchant@m.com"
                },
                "extendedData": {
                    "description": "ExtendedData can be supplied if the merchant wishes to send some arbitrary data back to the wallet.",
                    "type": "object",
                    "additionalProperties": true
                },
                "name": {
                    "description": "Name is a human readable string identifying the merchant.",
                    "type": "string",
                    "example": "merchant 1"
                }
            }
        },
        "dpp.Output": {
            "type": "object",
            "properties": {
                "amount": {
                    "description": "Amount is the number of satoshis to be paid.",
                    "type": "integer",
                    "example": 100000
                },
                "description": {
                    "description": "Description, an optional description such as \"tip\" or \"sales tax\". Maximum length is 100 chars.",
                    "type": "string",
                    "example": "paymentReference 123456"
                },
                "script": {
                    "description": "Script is a locking script where payment should be sent, formatted as a hexadecimal string.",
                    "type": "string",
                    "example": "76a91455b61be43392125d127f1780fb038437cd67ef9c88ac"
                }
            }
        },
        "dpp.PaymentACK": {
            "type": "object",
            "properties": {
                "error": {
                    "description": "A number indicating why the transaction was not accepted. 0 or undefined indicates no error.\nA 1 or any other positive integer indicates an error. The errors are left undefined for now;\nit is recommended only to use “1” and to fill the memo with a textual explanation about why\nthe transaction was not accepted until further numbers are defined and standardised.",
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "memo": {
                    "type": "string"
                },
                "peer_channel": {
                    "$ref": "#/definitions/dpp.PeerChannelData"
                },
                "tx_id": {
                    "type": "string"
                }
            }
        },
        "dpp.PaymentCreateArgs": {
            "type": "object",
            "properties": {
                "paymentID": {
                    "type": "string"
                }
            }
        },
        "dpp.PaymentDestinations": {
            "type": "object",
            "properties": {
                "outputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dpp.Output"
                    }
                }
            }
        },
        "dpp.PaymentTerms": {
            "type": "object",
            "properties": {
                "creationTimestamp": {
                    "description": "CreationTimestamp Unix timestamp (seconds since 1-Jan-1970 UTC) when the PaymentTerms was created.\nRequired.",
                    "type": "string",
                    "example": "2019-10-12T07:20:50.52Z"
                },
                "destinations": {
                    "description": "Destinations contains supported payment destinations by the merchant and dpp server, initial P2PKH outputs but can be extended.\nRequired.",
                    "$ref": "#/definitions/dpp.PaymentDestinations"
                },
                "expirationTimestamp": {
                    "description": "ExpirationTimestamp Unix timestamp (UTC) after which the PaymentTerms should be considered invalid.\nOptional.",
                    "type": "string",
                    "example": "2019-10-12T07:20:50.52Z"
                },
                "fees": {
                    "description": "FeeRate defines the amount of fees a users wallet should add to the payment\nwhen submitting their final payments.",
                    "$ref": "#/definitions/bt.FeeQuote"
                },
                "memo": {
                    "description": "Memo Optional note that should be displayed to the customer, explaining what this PaymentTerms is for.\nMaximum length is 50 characters.",
                    "type": "string",
                    "example": "invoice number 123456"
                },
                "merchantData": {
                    "description": "MerchantData contains arbitrary data that may be used by the payment host to identify the PaymentTerms.\nMay be omitted if the payment host does not need to associate Payments with PaymentTerms\nor if they associate each PaymentTerms with a separate payment address.\nMaximum length is 10000 characters.",
                    "$ref": "#/definitions/dpp.Merchant"
                },
                "network": {
                    "description": "Network  Always set to \"bitcoin\" (but seems to be set to 'bitcoin-sv'\noutside bip270 spec, see https://handcash.github.io/handcash-merchant-integration/#/merchant-payments)\n{enum: bitcoin, bitcoin-sv, test}\nRequired.",
                    "type": "string",
                    "enum": [
                        "mainnet",
                        "testnet",
                        "stn",
                        "regtest"
                    ],
                    "example": "mainnet"
                },
                "paymentUrl": {
                    "description": "PaymentURL secure HTTPS location where a Payment message (see below) will be sent to obtain a PaymentACK.\nMaximum length is 4000 characters",
                    "type": "string",
                    "example": "https://localhost:3443/api/v1/payment/123456"
                },
                "spvRequired": {
                    "description": "SPVRequired if true will expect the sender to submit an SPVEnvelope in the payment request, otherwise\na rawTx will be required.",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "dpp.PeerChannelData": {
            "type": "object",
            "properties": {
                "channel_id": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "envelope.JSONEnvelope": {
            "type": "object",
            "properties": {
                "encoding": {
                    "type": "string"
                },
                "mimetype": {
                    "type": "string"
                },
                "payload": {
                    "type": "string"
                },
                "publicKey": {
                    "type": "string"
                },
                "signature": {
                    "type": "string"
                }
            }
        },
        "server.ClientError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "example": "N01"
                },
                "id": {
                    "type": "string",
                    "example": "e97970bf-2a88-4bc8-90e6-2f597a80b93d"
                },
                "message": {
                    "type": "string",
                    "example": "unable to find foo when loading bar"
                },
                "title": {
                    "type": "string",
                    "example": "not found"
                }
            }
        }
    }
}`

type swaggerInfo struct {
	Version     string
	Host        string
	BasePath    string
	Schemes     []string
	Title       string
	Description string
}

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = swaggerInfo{
	Version:     "0.0.1",
	Host:        "localhost:8445",
	BasePath:    "",
	Schemes:     []string{},
	Title:       "Payment Protocol Server",
	Description: "Payment Protocol Server is an implementation of a Bip-270 payment flow.",
}

type s struct{}

func (s *s) ReadDoc() string {
	sInfo := SwaggerInfo
	sInfo.Description = strings.Replace(sInfo.Description, "\n", "\\n", -1)

	t, err := template.New("swagger_info").Funcs(template.FuncMap{
		"marshal": func(v interface{}) string {
			a, _ := json.Marshal(v)
			return string(a)
		},
		"escape": func(v interface{}) string {
			// escape tabs
			str := strings.Replace(v.(string), "\t", "\\t", -1)
			// replace " with \", and if that results in \\", replace that with \\\"
			str = strings.Replace(str, "\"", "\\\"", -1)
			return strings.Replace(str, "\\\\\"", "\\\\\\\"", -1)
		},
	}).Parse(doc)
	if err != nil {
		return doc
	}

	var tpl bytes.Buffer
	if err := t.Execute(&tpl, sInfo); err != nil {
		return doc
	}

	return tpl.String()
}

func init() {
	swag.Register(swag.Name, &s{})
}
